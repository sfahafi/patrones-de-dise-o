Requisito funcional

Un requisito funcional define una función del sistema de software o sus 
componentes. Una función es descrita como un conjunto de entradas, 
comportamientos y salidas. Los requisitos funcionales pueden ser: cálculos, 
detalles técnicos, manipulación de datos y otras funcionalidades específicas que
 se supone, un sistema debe cumplir. Los requerimientos de comportamiento para 
cada requerimiento funcional se muestran en los casos de uso. Son complementados
 por los requisitos no funcionales, que se enfocan en cambio en el diseño o la 
implementación.
Típicamente, un analista de requisitos genera requisitos funcionales después de 
realizar los casos de uso. Sin embargo, esto puede tener excepciones, ya que el 
desarrollo de software es un proceso iterativo y algunos requisitos son previos 
al diseño de los casos de uso. Ambos elementos (casos de uso y requisitos) se 
complementan en un proceso bidireccional.
Un requisito funcional típico contiene un nombre y un número de serie único y un 
resumen. Esta información se utiliza para ayudar al lector a entender por qué el
 requisito es necesario, y para seguir al mismo durante el desarrollo del 
producto.
El núcleo del requisito es la descripción del comportamiento requerido, que debe
 ser clara y concisa. Este comportamiento puede provenir de reglas 
organizacionales o del negocio, o ser descubiertas por interacción con usuarios,
 inversores y otros expertos en la organización.


Requisito no funcional

Un requisito no funcional o atributo de calidad es, en la ingeniería de sistemas
 y la ingeniería de software, un requisito que especifica criterios que pueden 
usarse para juzgar la operación de un sistema en lugar de sus comportamientos 
específicos, ya que éstos corresponden a los requisitos funcionales. Por tanto, 
se refieren a todos los requisitos que no describen información a guardar, ni 
funciones a realizar, sino características de funcionamiento.

Algunos ejemplos de requisitos no funcionales típicos son los siguientes:

    rendimiento
    disponibilidad
    accesibilidad
    usabilidad
    estabilidad
    portabilidad
    costo
    operatividad
    interoperabilidad
    escalabilidad
    concurrencia
    mantenibilidad
    interfaz
    seguridad
